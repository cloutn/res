


总体上的方案是有一个渲染的GeometryList之类的东西缓存窗口的渲染内容，当内容发生变化的时候，同步到硬件顶点。

UI渲染要解决的主要问题有两个：
1.渲染顺序和窗口遮盖关系之间的联系
2.尽量提高渲染效率

但是针对这两个问题，有以下两个不同的UI方案:

1.采用非常类似于CEGUI的方法，就是利用DrawPrimitive的顺序来控制窗口之间的覆盖关系。
在这种情况下，所有的窗口的z都被设置为0(其实无关紧要，只要统一一个值即可)。
缺点在于由于DrawPrimitive有严格的顺序关系，所以不能将使用相同纹理和渲染状态的顶点统一到一次DrawPrimitive中，因此当窗口和空间增多的时候，这种不能合并的多次渲染会对效率产生一定影响。
具体的实现参见CEGUI的下面两个函数：
Direct3D9GeometryBuffer::draw()
Direct3D9GeometryBuffer::performBatchManagement
基本上如果不是和上一个rect使用同一个纹理，那么就要新建一个Batch（渲染批次，指可以调用一次DrawPrimitive就绘制出来的所有顶点的集合）了。举例说明：假定batch数量为i，如果新添加进来的rect使用的纹理和第i个batch使用的纹理不一样，那么就会新建一个Batch，即便和i - 1或者i - 2个batch使用的纹理相同也没用，因为要用DrawPrimitive之间顺序（即Batch的顺序）来控制窗体的可见度，所以必须先绘制i - 1，在绘制i，最后绘制新加入的这个rect，所以新加入的rect不能和i - 1的rect合并。



2.使用z来控制窗体之间的可见度，这样做会使得窗体逻辑的z变得复杂，但是可以大量合并使用相同纹理的顶点，然后一次DrawPrimitive出来，渲染效率会较高。
但是这个方案有个问题，就是顶点更新的问题，比如，当控件内顶点改变了，如何能做到最少量的更新。解决更新有个临时的简单方案，就是每个window维护自己的独立的GeometryList，然后window内有东西更新，就刷新当前window。
“另外这个方案有个致命问题，就是z buffer会和场景冲突，除非采用渲染到纹理的方案“






